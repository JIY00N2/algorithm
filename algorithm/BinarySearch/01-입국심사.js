// 2023.06.14  17:00~17:52
function solution(n, times) {
  times.sort((a, b) => a - b);
  let left = 1; // 1분 젤 적게 걸리는 경우
  let right = n * times[times.length - 1]; // 60분 젤 오래걸리는 경우

  while (left <= right) {
    // 1. 중간 값 30분
    // 2. 29분
    // 3. 반복..
    let mid = Math.floor((left + right) / 2);

    // 1. 30분을 제한시간으로 두면 총 몇명이 입국 심사를 받나
    // 30/7 + 30/10 = 4+3 = 7명
    // 2. 29/7 + 29/10 = 4+2 = 6명
    const count = times.reduce((acc, cur) => acc + Math.floor(mid / cur), 0);
    // 1. 7명 >= 6명
    // 2. 6명 >= 6명
    if (count >= n) {
      // right = 29
      // right = 28
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return left;
}

/*
1. 알고리즘 or 자료구조 선택 이유
제한사항이 10억이라서 1억이상이면 O(logn)으로 끝내야 한다.
또한 이런 상황에서 이진 탐색이 자주 쓰인다.
이진 탐색 구현에는 배열과 이진 트리가 있는데 삽입, 삭제를 쓰지 않으므로 쉽게 구현할 수 있는 배열 구현 방식과 유사하게 구현했다.

2. 시간 복잡도 or 결과
시간복잡도: O(nlogn)? - sort()
이진 탐색 시간복잡도는 O(logn)

테스트 1 〉	통과 (0.18ms, 33.5MB)
테스트 2 〉	통과 (0.29ms, 33.5MB)
테스트 3 〉	통과 (2.13ms, 35.9MB)
테스트 4 〉	통과 (106.50ms, 43.4MB)
테스트 5 〉	통과 (147.91ms, 42.4MB)
테스트 6 〉	통과 (106.98ms, 42.4MB)
테스트 7 〉	통과 (205.32ms, 43.5MB)
테스트 8 〉	통과 (133.71ms, 43.5MB)
테스트 9 〉	통과 (0.20ms, 33.4MB)

3. 기타 의견
문제를 그냥 읽으면 이진탐색이 안 와닿을 수도 있을 것 같습니다.
문제를 읽기 전에 제한사항을 먼저 읽는 습관을 들이는 것이 좋을 것 같습니다!

4. 참고 링크
코드 참고: https://taesung1993.tistory.com/63
*/
